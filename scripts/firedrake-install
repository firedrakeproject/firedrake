#! /usr/bin/env python
from __future__ import absolute_import, print_function, division
import logging
import platform
import subprocess
import sys
import os
import shutil
from glob import glob
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from collections import OrderedDict
from distutils import dir_util
import atexit

adjoint_deps = {
    "libadjoint": "git+ssh://bitbucket.org/dolfin-adjoint/libadjoint.git",
    "dolfin-adjoint": "git+ssh://bitbucket.org/dolfin-adjoint/dolfin-adjoint.git"
}

# Packages which we wish to ensure are always recompiled
wheel_blacklist = ["mpi4py"]

# Firedrake application installation shortcuts.
firedrake_apps = {
    "gusto": ("""Atmospheric dynamical core library. http://firedrakeproject.org/gusto""",
              "git+ssh://github.com/firedrakeproject/gusto#egg=gusto"),
    "thetis": ("""Coastal ocean model. http://thetisproject.org""",
               "git+ssh://github.com/thetisproject/thetis#egg=thetis")
}


class InstallError(Exception):
    # Exception for generic install problems.
    pass


class FiredrakeConfiguration(dict):
    """A dictionary extended to facilitate the storage of Firedrake
    configuration information."""
    def __init__(self, args=None):
        super(FiredrakeConfiguration, self).__init__()

        '''A record of the persistent options in force.'''
        self["options"] = {}
        '''Relevant environment variables.'''
        self["environment"] = {}
        '''Additional packages installed via the plugin interface.'''
        self["additions"] = []

        if args:
            for o in self._persistent_options:
                if o in args.__dict__.keys():
                    self["options"][o] = args.__dict__[o]

    _persistent_options = ["developer", "package_manager",
                           "minimal_petsc", "mpicc", "disable_ssh",
                           "show_petsc_configure_options", "adjoint",
                           "slepc", "slope", "packages", "honour_pythonpath",
                           "petsc_int_type"]


def deep_update(this, that):
    import collections
    for k, v in that.items():
        if isinstance(v, collections.Mapping) and k in this.keys():
            this[k] = deep_update(this.get(k, {}), v)
        else:
            this[k] = v
    return this


if os.path.basename(__file__) == "firedrake-install":
    mode = "install"
elif os.path.basename(__file__) == "firedrake-update":
    mode = "update"
    os.chdir(os.path.dirname(__file__) + "/../..")
else:
    sys.exit("Script must be invoked either as firedrake-install or firedrake-update")

branches = {}

jenkins = "JENKINS_URL" in os.environ
ci_testing_firedrake = "FIREDRAKE_CI_TESTS" in os.environ


if mode == "install":
    # Handle command line arguments.
    parser = ArgumentParser(description="""Install firedrake and its dependencies.""",
                            epilog="""The install process has three steps.

1. Any required system packages are installed using brew (MacOS) or apt (Ubuntu
   and similar Linux systems). On a Linux system without apt, the installation
   will fail if a dependency is not found.

2. A set of standard and/or third party Python packages is installed to the
   specified install location.

3. The core set of Python packages is downloaded to ./firedrake/src/ and
   installed to the specified location.

The install creates a virtualenv in ./firedrake and installs inside
that virtualenv.

The installer will ensure that the required configuration options are
passed to PETSc. In addition, any configure options which you provide
in the PETSC_CONFIGURE_OPTIONS environment variable will be
honoured.""",
                            formatter_class=RawDescriptionHelpFormatter)

    parser.add_argument("--adjoint", action='store_true',
                        help="Also install firedrake-adjoint.")
    parser.add_argument("--slope", action='store_true',
                        help="Also install SLOPE. This enables loop tiling in PyOP2.")
    parser.add_argument("--slepc", action="store_true",
                        help="Install SLEPc along with PETSc.")
    parser.add_argument("--disable-ssh", "--disable_ssh", action="store_true",
                        help="Do not attempt to use ssh to clone git repositories: fall immediately back to https.")
    parser.add_argument("--no-package-manager", "--no_package_manager", action='store_false', dest="package_manager",
                        help="Do not attempt to use apt or homebrew to install operating system packages on which we depend.")
    parser.add_argument("--minimal-petsc", "--minimal_petsc", action="store_true",
                        help="Minimise the set of petsc dependencies installed. This creates faster build times (useful for build testing).")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--honour-petsc-dir", "--honour_petsc_dir", action="store_true",
                       help="Usually it is best to let Firedrake build its own PETSc. If you wish to use another PETSc, set PETSC_DIR and pass this option.")
    group.add_argument("--petsc-int-type", choices=["int32", "int64"],
                       default="int32", type=str,
                       help="The integer type used by PETSc.  Use int64 if you need to solve problems with more than 2 billion degrees of freedom.  Only takes effect if firedrake-install builds PETSc.")

    parser.add_argument("--honour-pythonpath", "--honour_pythonpath", action="store_true",
                        help="Pointing to external Python packages is usually a user error. Set this option if you know that you want PYTHONPATH set.")
    parser.add_argument("--rebuild-script", "--rebuild_script", action="store_true",
                        help="Only rebuild the firedrake-install script. Use this option if your firedrake-install script is broken and a fix has been released in upstream Firedrake. You will need to specify any other options which you wish to be honoured by your new update script.")
    parser.add_argument("--package-branch", "--package_branch", type=str, nargs=2, action="append", metavar=("PACKAGE", "BRANCH"),
                        help="Specify which branch of a package to use. This takes two arguments, the package name and the branch.")
    parser.add_argument("--verbose", "-v", action="store_true", help="Produce more verbose debugging output.")
    parser.add_argument("--mpicc", type=str,
                        action="store", default="mpicc",
                        help="C compiler to use when building with MPI (default is 'mpicc')")
    parser.add_argument("--show-petsc-configure-options", action="store_true",
                        help="Print out the configure options passed to PETSc")
    parser.add_argument("--virtualenv-name", default="firedrake",
                        type=str, action="store",
                        help="Name of the virtualenv to create (default is 'firedrake')")
    parser.add_argument("--install", action="append", dest="packages",
                        help="Additional packages to be installed. The address should be in format vcs+protocol://repo_url/#egg=pkg&subdirectory=pkg_dir . Some additional packages have shortcut install options for more information see --install_help.")
    parser.add_argument("--install-help", action="store_true",
                        help="Provide information on packages which can be installed using shortcut names.")

    args = parser.parse_args()

    if args.package_branch:
        branches = {package: branch for package, branch in args.package_branch}

    args.developer = True  # All new installations are developer mode, since there is no advantage to non-developer mode installs.
    args.prefix = False  # Disabled as untested
    args.packages = args.packages or []

    config = FiredrakeConfiguration(args)
else:
    class LegacyState(object):
        pass
    # The following args modifications are retained for backwards compatibility.
    # new options should not be added here.
    args = LegacyState()
    args.developer = False
    args.package_manager = False
    args.minimal_petsc = False
    args.rebuild_script = False
    args.mpicc = False
    args.disable_ssh = False
    args.show_petsc_configure_options = False
    args.adjoint = False
    args.slope = False
    args.slepc = False

    legacy_args = args.__dict__.copy()
    legacy = False
    try:
        import firedrake_configuration
        config = firedrake_configuration.get_config()
        if config is None:
            legacy = True
    except ImportError:
        legacy = True

    if legacy:
        config = {"options": args.__dict__}

    parser = ArgumentParser(description="""Update this firedrake install to the latest versions of all packages.""",
                            formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument("--no-update-script", action="store_false", dest="update_script",
                        help="Do not update script before updating Firedrake.")
    parser.add_argument("--rebuild", action="store_true",
                        help="Rebuild all packages even if no new version is available. Usually petsc and petsc4py are only rebuilt if they change. All other packages are always rebuilt.")
    parser.add_argument("--adjoint", action='store_true', dest="adjoint", default=config["options"]["adjoint"],
                        help="Also install firedrake-adjoint.")
    parser.add_argument("--slope", action='store_true', dest="slope", default=config["options"]["slope"],
                        help="Also install SLOPE. This enables loop tiling in PyOP2.")
    parser.add_argument("--slepc", action="store_true", dest="slepc", default=config["options"]["slepc"],
                        help="Install SLEPc along with PETSc")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--honour-petsc-dir", "--honour_petsc_dir", action="store_true",
                       help="Usually it is best to let Firedrake build its own PETSc. If you wish to use another PETSc, set PETSC_DIR and pass this option.")
    group.add_argument("--petsc-int-type", choices=["int32", "int64"],
                       default="int32", type=str,
                       help="The integer type used by PETSc.  Use int64 if you need to solve problems with more than 2 billion degrees of freedom.  Only takes effect if firedrake-install builds PETSc.")

    parser.add_argument("--honour-pythonpath", "--honour_pythonpath", action="store_true", default=config["options"].get("honour-pythonpath", False),
                        help="Pointing to external Python packages is usually a user error. Set this option if you know that you want PYTHONPATH set.")
    parser.add_argument("--clean", action='store_true',
                        help="Delete any remnants of obsolete Firedrake components.")
    parser.add_argument("--verbose", "-v", action="store_true", help="Produce more verbose debugging output.")
    parser.add_argument("--install", action="append", dest="packages", default=config["options"].get("packages", []),
                        help="Additional packages to be installed. The address should be in format vcs+protocol://repo_url/#egg=pkg&subdirectory=pkg_dir. Some additional packages have shortcut install options for more information see --install_help.")
    parser.add_argument("--install_help", action="store_true",
                        help="Provide information on packages which can be installed using shortcut names.")

    args = parser.parse_args()

    args.rebuild_script = legacy_args["rebuild_script"]

    args.packages = list(set(args.packages))  # remove duplicates

    petsc_int_type_changed = False
    if config["options"].get("petsc_int_type", "int32") != args.petsc_int_type:
        petsc_int_type_changed = True
        args.rebuild = True

    config = deep_update(config, FiredrakeConfiguration(args))
    if legacy:
        del legacy_args["adjoint"]
        del legacy_args["slope"]
        del legacy_args["slepc"]
        config["options"] = deep_update(config["options"], legacy_args)

if args.install_help:
    help_string = """
You can install the following packages by passing --install shortname
where shortname is one of the names given below:

"""
    componentformat = "|{:10}|{:70}|\n"
    header = componentformat.format("Name", "Description")
    line = "-" * (len(header) - 1) + "\n"
    help_string += line + header + line
    for package, d in firedrake_apps.items():
        help_string += componentformat.format(package, d[0])
    help_string += line
    print(help_string)
    sys.exit(0)

# Set up logging
# Log to file at DEBUG level
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)-6s %(message)s',
                    filename='firedrake-%s.log' % mode,
                    filemode='w')
# Log to console at INFO level
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter('%(message)s')
console.setFormatter(formatter)
logging.getLogger().addHandler(console)

log = logging.getLogger()

log.info("Running %s" % " ".join(sys.argv))


@atexit.register
def print_log_location():
    log.info("\n\n%s log saved in firedrake-%s.log" % (mode.capitalize(), mode))


class directory(object):
    """Context manager that executes body in a given directory"""
    def __init__(self, dir):
        self.dir = os.path.abspath(dir)

    def __enter__(self):
        self.olddir = os.path.abspath(os.getcwd())
        log.debug("Old path '%s'" % self.olddir)
        log.debug("Pushing path '%s'" % self.dir)
        os.chdir(self.dir)

    def __exit__(self, *args):
        log.debug("Popping path '%s'" % self.dir)
        os.chdir(self.olddir)
        log.debug("New path '%s'" % self.olddir)


options = config["options"]

# Apply short cut package names.
options["packages"] = [firedrake_apps.get(p, (None, p))[1] for p in options["packages"]]

# Where are packages installed relative to --root?
# This is a bit of a hack.
v = sys.version_info
sitepackages = "/usr/local/lib/python%d.%d/site-packages/" % (v.major, v.minor)

# Record of obsolete packages which --clean should remove from old installs.
old_git_packages = ["instant", "ffc"]

if mode == "install":
    firedrake_env = os.path.abspath(args.virtualenv_name)
else:
    try:
        firedrake_env = os.environ["VIRTUAL_ENV"]
    except KeyError:
        quit("Unable to retrieve virtualenv name from the environment.\n Please ensure the virtualenv is active before running firedrake-update.")

# virtualenv install
python = ["%s/bin/python" % firedrake_env]
# Use the pip from the virtualenv
pip = ["%s/bin/pip" % firedrake_env]
if jenkins:
    # Explicitly run python on pip because Jenkins can make illegaly long shebang lines.
    pip = python + pip
pipinstall = pip + ["install", "--no-binary", ",".join(wheel_blacklist)]
pyinstall = python + ["setup.py", "install"]
sitepackages = "%s/lib/python%d.%d/site-packages" % (firedrake_env, v.major, v.minor)

if "PYTHONPATH" in os.environ and not args.honour_pythonpath:
    quit("""The PYTHONPATH environment variable is set. This is probably an error.
If you really want to use your own Python packages, please run again with the
--honour-pythonpath option.
""")

petsc_opts = "--download-eigen=%s/src/eigen-3.3.3.tgz " % firedrake_env

if options["minimal_petsc"]:
    if options["petsc_int_type"] == "int64":
        petsc_opts += """--download-metis --download-parmetis --download-hdf5 --download-hypre --with-64-bit-indices"""
    else:
        petsc_opts += """--download-chaco --download-metis --download-parmetis --download-scalapack --download-hypre --download-mumps --download-hdf5"""
else:
    if options["petsc_int_type"] == "int64":
        petsc_opts += """--download-metis --download-parmetis --download-hypre --download-netcdf --download-hdf5 --download-exodusii --with-64-bit-indices"""
    else:
        petsc_opts += """--download-chaco --download-metis --download-parmetis --download-scalapack --download-hypre --download-mumps --download-netcdf --download-hdf5 --download-exodusii"""


if "PETSC_CONFIGURE_OPTIONS" not in os.environ:
    os.environ["PETSC_CONFIGURE_OPTIONS"] = petsc_opts
else:
    for opt in petsc_opts.split():
        if opt not in os.environ["PETSC_CONFIGURE_OPTIONS"]:
            os.environ["PETSC_CONFIGURE_OPTIONS"] += " " + opt

if mode == "update" and petsc_int_type_changed:
    log.warning("""Force rebuilding all packages because PETSc int type changed""")


def check_call(arguments, env=None):
    try:
        log.debug(subprocess.check_output(arguments, stderr=subprocess.STDOUT, env=env))
    except subprocess.CalledProcessError as e:
        log.debug(e.output)
        raise


def check_output(args, env=None):
    try:
        result = subprocess.check_output(args, stderr=subprocess.STDOUT, env=env)
        if isinstance(result, str):
            # Python 2
            return result
        else:
            # Python 3
            return result.decode()
    except subprocess.CalledProcessError as e:
        log.debug(e.output)
        raise


def brew_install(name, options=None):
    try:
        # Check if it's already installed
        check_call(["brew", "list", name])
    except subprocess.CalledProcessError:
        # If not found, go ahead and install
        arguments = [name]
        if options:
            arguments = options + arguments
        if args.verbose:
            arguments = ["--verbose"] + arguments
        check_call(["brew", "install"] + arguments)


def apt_check(name):
    log.info("Checking for presence of package %s..." % name)
    # Note that subprocess return codes have the opposite logical
    # meanings to those of Python variables.
    try:
        check_call(["dpkg-query", "-s", name])
        log.info("  installed.")
        return True
    except:
        log.info("  missing.")
        return False


def apt_install(names):
    log.info("Installing missing packages: %s." % ", ".join(names))
    if sys.stdin.isatty():
        subprocess.check_call(["sudo", "apt-get", "install"] + names)
    else:
        log.info("Non-interactive stdin detected; installing without prompts")
        subprocess.check_call(["sudo", "apt-get", "-y", "install"] + names)


def split_requirements_url(url):
    name = url.split(".git")[0].split("#")[0].split("/")[-1]
    spliturl = url.split("://")[1].split("#")[0].split("@")
    try:
        plain_url, branch = spliturl
    except ValueError:
        plain_url = spliturl[0]
        branch = "master"
    return name, plain_url, branch


def git_url(plain_url, protocol):
    if protocol == "ssh":
        return "git@%s:%s" % tuple(plain_url.split("/", 1))
    elif protocol == "https":
        return "https://%s" % plain_url
    else:
        raise ValueError("Unknown git protocol: %s" % protocol)


def update_and_apply_petsc_fix():
    HEAD1 = check_output(["git", "rev-parse", "HEAD~"]).strip()
    # Fetch from upstream
    check_call(["git", "fetch", "origin"])
    # Check if we've applied horrific monkey-patching
    magic_sha = "156a1856fd44f55220132393778f0fda1e6096e3"
    if HEAD1 == magic_sha:
        # Yes, check if the upstream branch pointer has
        # changed, in which case we can reset to upstream.
        log.info("Already applied eigen fix, checking if upstream is newer")
        remote_sha = check_output(["git", "rev-parse", "origin/firedrake"]).strip()
        if remote_sha != magic_sha:
            log.info("Upstream is newer, resetting to upstream")
            check_call(["git", "reset", "--hard", magic_sha])
            check_call(["git", "pull"])
    else:
        # Update, then check if we need to apply a patch.
        check_call(["git", "pull"])
        HEAD = check_output(["git", "rev-parse", "HEAD"]).strip()
        if HEAD == magic_sha:
            # No, and we need to, so apply the fix.
            log.info("Apply temporary --download-eigen fix")
            patch = """\
From a2a264416ccac135640344f54852f6b74bf9de1e Mon Sep 17 00:00:00 2001
From: Lawrence Mitchell <lawrence.mitchell@imperial.ac.uk>
Date: Tue, 11 Apr 2017 10:35:04 +0100
Subject: [PATCH] Temporary workaround for --download-eigen --prefix issues

---
 config/BuildSystem/config/package.py        | 2 ++
 config/BuildSystem/config/packages/eigen.py | 2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/config/BuildSystem/config/package.py b/config/BuildSystem/config/package.py
index ba78667..6aa03bb 100644
--- a/config/BuildSystem/config/package.py
+++ b/config/BuildSystem/config/package.py
@@ -351,6 +351,8 @@ class Package(config.base.Configure):
   def generateGuesses(self):
     d = self.checkDownload()
     if d:
+      if not self.liblist:
+        yield('Download '+self.PACKAGE, d, [], self.getIncludeDirs(d, self.includedir))
       for libdir in [self.libdir, self.altlibdir]:
         libdirpath = os.path.join(d, libdir)
         if not os.path.isdir(libdirpath):
diff --git a/config/BuildSystem/config/packages/eigen.py b/config/BuildSystem/config/packages/eigen.py
index 1353c04..e136e6f 100644
--- a/config/BuildSystem/config/packages/eigen.py
+++ b/config/BuildSystem/config/packages/eigen.py
@@ -7,7 +7,7 @@ class Configure(config.package.CMakePackage):
     self.download          = ['hg://https://bitbucket.org/eigen/eigen/']
     self.functions         = []
     self.includes          = ['Eigen/Core']
-    self.liblist           = [[]]
+    self.liblist           = []
     self.cxx               = 1
     self.includedir        = os.path.join('include', 'eigen3')
     self.useddirectly      = 0
--
2.7.0.297.g563e384
"""
            try:
                p = subprocess.Popen(["git", "am"], stdout=subprocess.PIPE,
                                     stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
                p.communicate(input=patch)
            except subprocess.CalledProcessError as e:
                log.debug(e.output)
                raise


def git_clone(url):
    name, plain_url, branch = split_requirements_url(url)
    if name == "petsc" and args.honour_petsc_dir:
        log.info("Using existing petsc installation\n")
        return name
    log.info("Cloning %s\n" % name)
    if name in branches:
        branch = branches[name]
    try:
        if options["disable_ssh"]:
            raise Exception
        check_call(["git", "clone", "-q", git_url(plain_url, "ssh")])
        log.info("Successfully cloned repository %s" % name)
    except:
        if not options["disable_ssh"]:
            log.warn("Failed to clone %s using ssh, falling back to https." % name)
        try:
            check_call(["git", "clone", "-q", git_url(plain_url, "https")])
            log.info("Successfully cloned repository %s." % name)
        except subprocess.CalledProcessError:
            log.error("Failed to clone %s branch %s." % (name, branch))
            raise
    with directory(name):
        try:
            log.info("Checking out branch %s" % branch)
            check_call(["git", "checkout", "-q", branch])
            log.info("Successfully checked out branch %s" % branch)
        except subprocess.CalledProcessError:
            log.error("Failed to check out branch %s" % branch)
            raise
        if name == "petsc":
            update_and_apply_petsc_fix()
    return name


def list_cloned_dependencies(name):
    log.info("Finding dependencies of %s\n" % name)
    deps = OrderedDict()
    try:
        for dep in open(name + "/requirements-git.txt", "r"):
            name = split_requirements_url(dep.strip())[0]
            deps[name] = dep.strip()
    except IOError:
        pass
    return deps


def clone_dependencies(name):
    log.info("Cloning the dependencies of %s" % name)
    deps = []
    try:
        for dep in open(name + "/requirements-git.txt", "r"):
            deps.append(git_clone(dep.strip()))
    except IOError:
        pass
    return deps


def git_update(name, url=None):
    # Update the named git repo and return true if the current branch actually changed.
    log.info("Updating the git repository for %s" % name)
    with directory(name):
        git_sha = check_output(["git", "rev-parse", "HEAD"])
        # Ensure remotes get updated if and when we move repositories.
        if url:
            plain_url = split_requirements_url(url)[1]
            current_url = check_output(["git", "remote", "-v"]).split()[1]
            protocol = "https" if current_url.startswith("https") else "ssh"
            new_url = git_url(plain_url, protocol)
            # Ensure we only change from bitbucket to github and not the reverse.
            if new_url != current_url and "bitbucket.org" in current_url \
               and "github.com/firedrakeproject" in plain_url:
                log.info("Updating git remote for %s" % name)
                check_call(["git", "remote", "set-url", "origin", new_url])
        if name == "petsc":
            update_and_apply_petsc_fix()
        else:
            check_call(["git", "pull"])
        git_sha_new = check_output(["git", "rev-parse", "HEAD"])
    return git_sha != git_sha_new


def run_pip(args):
    log.info(" ".join(pip + args))
    check_call(pip + args)


def run_pip_install(pipargs):
    # Make pip verbose when logging, so we see what the
    # subprocesses wrote out.
    # Particularly important for debugging petsc fails.
    pipargs = ["-vvv"] + pipargs
    log.debug(" ".join(pipinstall + pipargs) + "\n")
    check_call(pipinstall + pipargs)


def run_cmd(args):
    log.info(" ".join(args) + "\n")
    check_call(args)


def pip_requirements(package):
    log.info("Installing pip dependencies for %s" % package)
    if os.path.isfile("%s/requirements-ext.txt" % package):
        run_pip_install(["-r", "%s/requirements-ext.txt" % package])
    elif os.path.isfile("%s/requirements.txt" % package):
        if package == "COFFEE":
            # FIXME: Horrible hack to work around
            # https://github.com/coin-or/pulp/issues/123
            run_pip_install(["--no-deps", "-r", "%s/requirements.txt" % package])
        else:
            run_pip_install(["-r", "%s/requirements.txt" % package])
    else:
        log.info("No dependencies found. Skipping.")


def install(package):
    log.info("Installing %s" % package)
    if package == "petsc/":
        build_and_install_petsc()
    # The following outrageous hack works around the fact that petsc cannot be installed in developer mode.
    elif options["developer"] and package not in ["petsc/", "petsc4py/", "slepc/", "slepc4py/"]:
        run_pip_install(["-e", package])
    else:
        run_pip_install(["--ignore-installed", package])


def clean(package):
    log.info("Cleaning %s" % package)
    with directory(package):
        check_call(["python", "setup.py", "clean"])


def pip_uninstall(package):
    log.info("Removing existing %s installations\n" % package)
    # Uninstalling something with pip is an absolute disaster.  We
    # have to use pip freeze to list all available packages "locally"
    # and keep on removing the one we want until it is gone from this
    # list!  Yes, pip will happily have two different versions of the
    # same package co-existing.  Moreover, depending on the phase of
    # the moon, the order in which they are uninstalled is not the
    # same as the order in which they appear on sys.path!
    again = True
    i = 0
    while again:
        # List installed packages, "locally".  In a virtualenv,
        # this just tells me packages in the virtualenv, otherwise it
        # gives me everything.
        lines = check_output(pip + ["freeze", "-l"])
        again = False
        for line in lines.split("\n"):
            # Do we have a locally installed package?
            if line.startswith(package):
                # Uninstall it.
                run_pip(["uninstall", "-y", line.strip()])
                # Go round again, because THERE MIGHT BE ANOTHER ONE!
                again = True
        i += 1
        if i > 10:
            raise InstallError("pip claims it uninstalled %s more than 10 times.  Something is probably broken.", package)


def build_and_install_petsc():
    import hashlib
    import urllib
    tarball = "eigen-3.3.3.tgz"
    url = "https://bitbucket.org/eigen/eigen/get/3.3.3.tar.gz"
    sha = hashlib.sha256()
    expect = "94878cbfa27b0d0fbc64c00d4aafa137f678d5315ae62ba4aecddbd4269ae75f"
    if not os.path.exists(tarball):
        log.info("Downloading Eigen from '%s' to '%s'" % (url, tarball))
        urllib.urlretrieve(url, filename=tarball)
    else:
        log.info("Eigen tarball already downloaded to '%s'" % tarball)
    log.info("Checking Eigen tarball integrity")
    with open(tarball, "rb") as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            sha.update(data)
    actual = sha.hexdigest()
    if actual != expect:
        raise InstallError("Downloaded Eigen tarball has incorrect sha256sum, expected '%s', was '%s'",
                           expect, actual)
    else:
        log.info("Eigen tarball hash valid")
    run_pip_install(["--ignore-installed", "petsc/"])


def build_and_install_h5py():
    import shutil
    log.info("Installing h5py")
    # Clean up old downloads
    if os.path.exists("h5py-2.5.0"):
        log.info("Removing old h5py-2.5.0 source")
        shutil.rmtree("h5py-2.5.0")
    if os.path.exists("h5py.tar.gz"):
        log.info("Removing old h5py.tar.gz")
        os.remove("h5py.tar.gz")

    url = "git+https://github.com/firedrakeproject/h5py.git@firedrake#egg=h5py"
    if os.path.exists("h5py"):
        changed = False
        with directory("h5py"):
            # Rewrite old h5py/h5py remote to firedrakeproject/h5py remote.
            plain_url = split_requirements_url(url)[1]
            current_remote = check_output(["git", "remote", "-v"]).split()[1]
            proto = "https" if current_remote.startswith("https") else "ssh"
            new_remote = git_url(plain_url, proto)
            if new_remote != current_remote and "h5py/h5py.git" in current_remote:
                log.info("Updating git remote for h5py from %s to %s", current_remote, new_remote)
                check_call(["git", "remote", "set-url", "origin", new_remote])
                check_call(["git", "fetch", "-p", "origin"])
                check_call(["git", "checkout", "firedrake"])
                changed = True
        changed |= git_update("h5py")
    else:
        git_clone(url)
        changed = True

    if args.honour_petsc_dir:
        petsc_dir = os.environ["PETSC_DIR"]
        petsc_arch = os.environ.get("PETSC_ARCH", "")
    else:
        try:
            petsc_dir = check_output(python +
                                     ["-c", "import petsc; print(petsc.get_petsc_dir())"]).strip()

            petsc_arch = ""
        except subprocess.CalledProcessError:
            raise InstallError("Unable to find installed PETSc when building h5py")

    hdf5_dir = "%s/%s" % (petsc_dir, petsc_arch)
    if changed or args.rebuild:
        log.info("Linking h5py against PETSc found in %s\n" % hdf5_dir)
        oldcc = os.environ.get("CC", None)
        os.environ["CC"] = options["mpicc"] or "mpicc"
        os.environ["HDF5_DIR"] = hdf5_dir
        os.environ["HDF5_MPI"] = "ON"
        # Only uninstall if things changed.
        pip_uninstall("h5py")
        # Pip installing from dirty directory is potentially unsafe.
        with directory("h5py/"):
            check_call(["git", "clean", "-fdx"])
        install("h5py/")
        if oldcc is None:
            del os.environ["CC"]
        else:
            os.environ["CC"] = oldcc
    else:
        log.info("No need to rebuild h5py")


def build_and_install_glpsol():
    log.info("Installing GLPK")
    if os.path.exists("glpk"):
        glpk_changed = git_update("glpk")
    else:
        git_clone("git+https://github.com/firedrakeproject/glpk.git")
        glpk_changed = True

    if glpk_changed:
        with directory("glpk"):
            check_call(["./configure", "--disable-shared", "--disable-static"])
            check_call(["make"])
            check_call(["cp", "examples/glpsol", os.environ["VIRTUAL_ENV"] + "/bin/"])
    else:
        log.info("No need to rebuild glpk")


def build_and_install_libspatialindex():
    log.info("Installing libspatialindex")
    if os.path.exists("libspatialindex"):
        log.info("Updating the git repository for libspatialindex")
        with directory("libspatialindex"):
            check_call(["git", "fetch"])
            git_sha = check_output(["git", "rev-parse", "HEAD"])
            git_sha_new = check_output(["git", "rev-parse", "@{u}"])
            libspatialindex_changed = git_sha != git_sha_new
            if libspatialindex_changed:
                check_call(["git", "reset", "--hard"])
                check_call(["git", "pull"])
    else:
        git_clone("git+https://github.com/firedrakeproject/libspatialindex.git")
        libspatialindex_changed = True

    if libspatialindex_changed:
        with directory("libspatialindex"):
            # Clean source directory
            check_call(["git", "reset", "--hard"])
            check_call(["git", "clean", "-f", "-x", "-d"])
            # Patch Makefile.am to skip building test
            check_call(["sed", "-i", "-e", "/^SUBDIRS/s/ test//", "Makefile.am"])
            # Build and install
            check_call(["./autogen.sh"])
            check_call(["./configure", "--prefix=" + sys.prefix,
                        "--enable-shared", "--disable-static"])
            check_call(["make"])
            check_call(["make", "install"])
    else:
        log.info("No need to rebuild libspatialindex")


def build_and_install_slepc():
    try:
        petsc_dir = check_output(python + ["-c", "import petsc; print(petsc.get_petsc_dir())"]).strip()
        petsc_arch = ""
    except subprocess.CalledProcessError:
        raise InstallError("Unable to find installed PETSc when building SLEPc")

    env = dict(os.environ)
    env["PETSC_ARCH"] = petsc_arch
    env["PETSC_DIR"] = petsc_dir

    log.info("Installing SLEPc.")
    if os.path.exists("slepc"):
        slepc_changed = git_update("slepc")
    else:
        git_clone("git+https://bitbucket.org/slepc/slepc.git")
        slepc_changed = True
    if slepc_changed:
        install("slepc/")
    else:
        log.info("No need to rebuild slepc")

    log.info("Installing slepc4py.")
    if os.path.exists("slepc4py"):
        slepc4py_changed = git_update("slepc4py")
    else:
        git_clone("git+https://bitbucket.org/slepc/slepc4py.git")
        slepc4py_changed = True
    if slepc4py_changed:
        install("slepc4py/")
    else:
        log.info("No need to rebuild slepc4py")


def build_and_install_adjoint():

    for package in adjoint_deps:
        try:
            git_update(package, adjoint_deps[package])
        except OSError as e:
            if e.errno == 2:
                log.warn("%s missing, cloning anew.\n" % package)
                git_clone(adjoint_deps[package])
            else:
                raise

    if args.honour_petsc_dir:
        petsc_dir = os.environ["PETSC_DIR"]
        petsc_arch = os.environ.get("PETSC_ARCH", "")
    else:
        try:
            petsc_dir = check_output(python +
                                     ["-c", "import petsc; print(petsc.get_petsc_dir())"]).strip()

            petsc_arch = ""
        except subprocess.CalledProcessError:
            raise InstallError("Unable to find installed PETSc when building h5py")

    env = dict(os.environ)
    env["PETSC_ARCH"] = petsc_arch
    env["PETSC_DIR"] = petsc_dir

    with directory("libadjoint"):
        dir_util.mkpath("build")
        with directory("build"):
            log.info("Configuring libadjoint for virtualenv installation in %s" % os.environ["VIRTUAL_ENV"])
            check_call(["cmake", "-DCMAKE_INSTALL_PREFIX=%s" % os.environ["VIRTUAL_ENV"], ".."], env=env)
            log.info("Installing libadjoint.")
            check_call(["make", "install"])

    install("dolfin-adjoint/")


def build_and_install_slope():
    log.info("Installing SLOPE")
    if os.path.exists("SLOPE"):
        slope_changed = git_update("SLOPE")
    else:
        git_clone("git+https://github.com/coneoproject/SLOPE.git")
        slope_changed = True

    if slope_changed:
        with directory("SLOPE"):
            # Clean source directory
            check_call(["git", "reset", "--hard"])
            check_call(["git", "clean", "-f", "-x", "-d"])
            # Build and install (hack: need to do this manually as SLOPE is
            # still stupid and doesn't have a proper configure+make+install system)
            check_call(["make"])
            check_call(["mv"] + glob(os.path.join('lib', '*')) + [os.path.join(sys.prefix, 'lib')])
            include_dir = os.path.join(sys.prefix, 'include', 'SLOPE')
            check_call(["mkdir", "-p", include_dir])
            check_call(["cp"] + glob(os.path.join('sparsetiling', 'include', '*')) + [include_dir])
            # Also install the Python interface
            run_cmd(pyinstall)
    else:
        log.info("No need to rebuild SLOPE")


def clean_obsolete_packages():
    dirs = os.listdir(".")
    for package in old_git_packages:
        pip_uninstall(package)
        if package in dirs:
            shutil.rmtree(package)


def quit(message):
    log.error(message)
    sys.exit(1)


def build_update_script():
    log.info("Creating firedrake-update script.")
    with open("firedrake/scripts/firedrake-install", "r") as f:
        update_script = f.read()

    try:
        os.mkdir("../bin")
    except:
        pass
    with open("../bin/firedrake-update", "w") as f:
        f.write(update_script)
    check_call(["chmod", "a+x", "../bin/firedrake-update"])


if options["show_petsc_configure_options"]:
    log.info("******************************************\n")
    log.info("Building PETSc with the following options:\n")
    log.info("******************************************\n")
    log.info("%s\n\n" % os.environ["PETSC_CONFIGURE_OPTIONS"])

if args.rebuild_script:
    os.chdir(os.path.dirname(os.path.realpath(__file__)) + ("/../.."))

    build_update_script()

    log.info("Successfully rebuilt firedrake-update.\n")

    log.info("To upgrade firedrake, run firedrake-update")
    sys.exit(0)


if "PETSC_DIR" in os.environ and not args.honour_petsc_dir:
    quit("""The PETSC_DIR environment variable is set. This is probably an error.
If you really want to use your own PETSc build, please run again with the
--honour-petsc-dir option.
""")


log.debug("*** Current environment (output of 'env') ***")
log.debug(check_output(["env"]))
log.debug("\n\n")


# Check operating system.
osname = platform.uname()[0]
if osname == "Darwin":
    if options["package_manager"]:

        log.info("Installing command line tools...")
        try:
            check_call(["xcode-select", "--install"])
        except subprocess.CalledProcessError:
            # expected failure if already installed
            pass

        try:
            check_call(["brew", "--version"])
        except:
            quit("Homebrew not found. Please install it using the instructions at http://brew.sh and then try again.")

        log.info("Installing required packages via homebrew. You can safely ignore warnings that packages are already installed")
        # Ensure a fortran compiler is available
        brew_install("gcc")
        brew_install("openmpi")
        brew_install("python")
        brew_install("autoconf")
        brew_install("automake")
        brew_install("cmake")
        brew_install("libtool")
        brew_install("mercurial")

    else:
        log.info("Xcode and homebrew installation disabled. Proceeding on the rash assumption that packaged dependencies are in place.")

elif osname == "Linux":
    # Check for apt.
    try:
        if not options["package_manager"]:
            raise InstallError
        check_call(["apt-get", "--version"])

        apt_packages = ["build-essential",
                        "autoconf",
                        "automake",
                        "cmake",
                        "gfortran",
                        "git-core",
                        "libblas-dev",
                        "liblapack-dev",
                        "libopenmpi-dev",
                        "libtool",
                        "mercurial",
                        "openmpi-bin",
                        "python-dev",
                        "python-pip",
                        "python-tk",
                        "zlib1g-dev"]

        missing_packages = [p for p in apt_packages if not apt_check(p)]
        if missing_packages:
            apt_install(missing_packages)

    except (subprocess.CalledProcessError, InstallError):
        log.info("apt-get not found or disabled. Proceeding on the rash assumption that your compiled dependencies are in place.")
        log.info("If this is not the case, please install the following and try again:")
        log.info("* A C and C++ compiler (for example gcc/g++ or clang), GNU make")
        log.info("* A Fortran compiler (for PETSc)")
        log.info("* MPI")
        log.info("* Blas and Lapack")
        log.info("* Git, Mercurial")
        log.info("* Python version 2.7")
        log.info("* pip and the Python headers")
        log.info("* autoconf, automake, libtool")
        log.info("* CMake")
        log.info("* zlib")

else:
    log.warn("You do not appear to be running Linux or MacOS. Please do not be surprised if this install fails.")


if mode == "install":
    if os.path.exists(firedrake_env):
        log.warning("Specified virtualenv '%s' already exists", firedrake_env)
        quit("Can't install into existing virtualenv '%s'" % firedrake_env)
    try:
        import virtualenv
    except:
        log.info("Installing virtualenv.")
        # sys.real_prefix exists if we are already in the virtualenv
        if hasattr(sys, "real_prefix"):
            check_call(["pip", "install", "virtualenv"])
        else:
            check_call(["pip", "install", "--user", "virtualenv"])
        quit("Virtual env installed. Please run firedrake-%s again." % mode)
    log.info("Creating firedrake virtualenv in '%s'." % firedrake_env)
    virtualenv.create_environment(firedrake_env, site_packages=False)
    # Ensure pip and setuptools are at the latest version.
    run_pip(["install", "-U", "setuptools"])
    run_pip(["install", "-U", "pip"])

virtual_env_vars = dict(__file__='%s/bin/activate_this.py' % firedrake_env)
exec(open("%s/bin/activate_this.py" % firedrake_env).read(), virtual_env_vars)
# Activating the virtual_env from within Python does not automatically set the environment variable.
os.environ["VIRTUAL_ENV"] = virtual_env_vars["base"]

os.chdir(firedrake_env)

if mode == "install":
    os.mkdir("src")
    os.chdir("src")

    if jenkins and ci_testing_firedrake:
        check_call(["ln", "-s", "../../../", "firedrake"])
    else:
        git_clone("git+https://github.com/firedrakeproject/firedrake.git")

    packages = clone_dependencies("firedrake")
    packages = clone_dependencies("PyOP2") + packages
    packages += ["firedrake"]

    for p in options["packages"]:
        name = git_clone(p)
        packages.extend(clone_dependencies(name))
        packages += [name]

    if args.honour_petsc_dir:
        packages.remove("petsc")

    # Force Cython to install first to work around pip dependency issues.
    run_pip_install(["Cython>=0.22"])

    # Need to install petsc first in order to resolve hdf5 dependency.
    if not args.honour_petsc_dir:
        pipinstall.append("--no-deps")
        packages.remove("petsc")
        log.info("Depending on your platform, PETSc may take an hour or more to build!")
        install("petsc/")
        pipinstall.pop()

    for p in packages:
        pip_requirements(p)

    build_and_install_h5py()
    build_and_install_glpsol()
    build_and_install_libspatialindex()
    pipinstall.append("--no-deps")
    for p in packages:
        install(p+"/")
        if options["developer"]:
            sys.path.append(os.getcwd() + "/" + p)

    # Work around easy-install.pth bug.
    if options["developer"]:
        try:
            packages.remove("petsc")
        except ValueError:
            pass
        packages.remove("petsc4py")
        packages.remove("firedrake")
        v = sys.version_info
        if v.major <= 2:
            easyinstall = open("../lib/python%d.%d/site-packages/easy-install.pth" % (v.major, v.minor), "r").readlines()
            new_packages = [os.getcwd() + "/" + p + "\n" for p in packages]
            open("../lib/python%d.%d/site-packages/easy-install.pth" % (v.major, v.minor), "w").writelines(
                easyinstall[:1] + new_packages + easyinstall[1:])

    build_update_script()

else:
    # Update mode
    os.chdir("src")

    if args.update_script:
        # Pull firedrake, rebuild update script, launch new script
        git_update("firedrake")
        build_update_script()
        os.execv(sys.executable, [sys.executable, "../bin/firedrake-update", "--no-update-script"] + sys.argv[1:])

    deps = OrderedDict()
    deps.update(list_cloned_dependencies("PyOP2"))
    deps.update(list_cloned_dependencies("firedrake"))
    for p in options["packages"]:
        name = split_requirements_url(p)[0]
        deps.update(list_cloned_dependencies(name))
        deps[name] = p
    packages = list(deps.keys())
    packages += ["firedrake"]

    # update packages.
    if not args.honour_petsc_dir:
        petsc_changed = git_update("petsc", deps["petsc"])
    else:
        petsc_changed = False
    petsc4py_changed = git_update("petsc4py", deps["petsc4py"])

    packages.remove("petsc")
    packages.remove("petsc4py")

    # Forcibly upgrade old installations to developer mode.
    if not options["developer"]:
        forced_developer = True
        args.clean = True
        options["developer"] = True
    else:
        forced_developer = False

    if args.clean:
        try:
            clean_obsolete_packages()
            for package in packages:
                pip_uninstall(package)
            if args.rebuild:
                pip_uninstall("petsc")
                pip_uninstall("petsc4py")
        except:
            if forced_developer:
                log.error("*************************************************************")
                log.error("* Uninstalling packages failed while attemping to upgrade   *")
                log.error("* your installation to developer mode.                      *")
                log.error("*                                                           *")
                log.error("* Please try running firedrake-update again, and if the     *")
                log.error("* problem persists, please raise an issue via github, the   *")
                log.error("* email list or the slack channel.                          *")
                log.error("*************************************************************")

            raise

    for p in packages:
        try:
            git_update(p, deps.get(p, None))
        except OSError as e:
            if e.errno == 2:
                log.warn("%s missing, cloning anew.\n" % p)
                git_clone(deps[p])
            else:
                raise

    # update dependencies.
    for p in packages:
        pip_requirements(p)
    pipinstall.append("--no-deps")

    # Only rebuild petsc if it has changed.
    if not args.honour_petsc_dir and (args.rebuild or petsc_changed):
        clean("petsc/")
        log.info("Depending on your platform, PETSc may take an hour or more to build!")
        install("petsc/")
    if args.rebuild or petsc_changed or petsc4py_changed:
        clean("petsc4py/")
        install("petsc4py/")

    # Always rebuild h5py.
    build_and_install_h5py()
    build_and_install_glpsol()
    build_and_install_libspatialindex()

    try:
        packages.remove("PyOP2")
        packages.remove("firedrake")
    except ValueError:
        pass
    packages += ("PyOP2", "firedrake")
    for p in packages:
        clean(p)
        install(p+"/")

if options["adjoint"]:
    build_and_install_adjoint()
if options["slepc"]:
    build_and_install_slepc()
if options["slope"]:
    build_and_install_slope()


if mode == "update":
    try:
        log.info("Clearing just in time compilation caches.")
        from firedrake.tsfc_interface import clear_cache, TSFCKernel
        from pyop2.compilation import clear_cache as pyop2_clear_cache
        print('Removing cached TSFC kernels from %s' % TSFCKernel._cachedir)
        clear_cache()
        pyop2_clear_cache()
    except:
        # Unconditional except in order to avoid upgrade script failures.
        log.error("Failed to clear caches. Try running firedrake-clean.")


os.chdir("../..")

log.info("\n\nSuccessfully installed Firedrake.\n")

log.info("\nFiredrake has been installed in a python virtualenv. You activate it with:\n")
log.info("  . %s/bin/activate\n" % firedrake_env)
log.info("The virtualenv can be deactivated by running:\n")
log.info("  deactivate\n\n")
log.info("To upgrade Firedrake activate the virtualenv and run firedrake-update\n")


try:
    import firedrake_configuration
    firedrake_configuration.write_config(config)
    log.info("Configuration saved to configuration.json")
except Exception as e:
    log.info("Unable to save configuations to a JSON file")
    log.info("Error Message:")
    log.info(e.message)
